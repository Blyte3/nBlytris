Libraries used
	stdlib for rand()
	time for rand seed
	ncurses (subject to change) just so you can see what's happening
	
Compilation
	Compilation is done with tcc, or tiny c compiler. Compilation with gcc is also possible. Other compilers not tested, but probably work
	Just be sure to link the ncurses library with -lncurses

graphics.h
	Blytris core is meant to be seperate from graphics drawing, so that it is easy to make a new gui
	This is just a header for a few functions that print out board, queue, and hold
	It's sloppily written, and so not as clear as the game logic. Note that it might eventually be deprecated for another library that looks better and handles input
	
	Functions
		
		ChangeColor
			changes the color ncurses will print in when given the piece number+1 as an argument (ijlostz, i is 1 after adding). 0 will print out cyan on black
		
		PrintRow
			prints out a row on the board, as given by an argument. also prints out "|" as the sides of the board
			color of the row is given by simply using ChangeColor with the board position to be printed as an argument
			
		PrintPiece
			prints out a row from the big array PieceImage, accepting which row and which piece as an argument
			color of the row is given by ChangeColor
			
		PrintBoard
			first, manually prints out the first two rows of the board including queue and hold piece. this is done with printpiece and printrow
			then print out rows until the 5 queue pieces are printed. Some additional variables keep track of what piece to print and what row of pieceimage to use 
			finally print the final rows with no queue
			
		PrintActive
			writes the active piece to board[][] so it can be read by PrintBoard
			
		RemoveActive
			removes the active piece from board[][] right after board is printed so it does not mess with the logic
			
		InitGraphics
			inits ncurses
			inits colors
			inits color white as orange
			inits all the color pairs
			does an initial print of the board so that the screen is not blank until first input

Functions

	BuildStack
		Builds the stack
			Simply sets all values in board[10][25] to zero
	
	GenBag
		Generates a randomized set of seven pieces using the bag randomizer, puts them in bag[]
	 		Pieces are generated by starting with an array of all 7 pieces (randpieces[]), 0,1,2,3,4,5,6
	 		The following will be put in a decrement loop the size of the bag (7)	
	 			A random number between 0 and r-1 is chosen, and that number is used to index the array of seven pieces
	 			The piece that is indexed will be put as the first element in bag[]
	 			The index in randpieces will then be swapped with element r-1, so that it will not be picked in the next random index
	 			
	LineClear
		Checks four y locations on the board to see if lines need to be cleared (if all x locations across y are not empty)
			The four y locations that are to be checked are provided by setting an array in the hard drop function
				The y location's x is incremented through, and if a zero (empty space) is found, it stops
				If the increment loop did not stop, then go clear the line at that y point
					First look through the remaining y values to check if any are greater than the y point that you are clearing at, decrement it
					This is done because the stack will move down after clearing, so the lines that will be cleared next will also need to move down
					All the x values across the y point will then be set to zero, or cleared
					All the board above the line clear will be moved down one unit
					
	MoveQueue
		Manages queue randomization and movement
			The queue is accessed by generating an array[14] of bag generated pieces (see GenBag), and then by moving the point at which the array is accessed
				Increments queueaccesspoint, (self explanatory)
				If queue accesspoint is halfway through the array
					Move the back half to the front half, and generate a new bag for the back half. Set queue accesspoint to the start of the array again
				Set activepiece to queue[queueaccesspoint]
					
	InitialQueue
		Generates an initial queue
			Generate two random bags (see GenBag), one for the first half of the queue, another for the second
			Set queueaccesspoint to the start of the queue and activepiece to queue[queueaccesspoint]
			
	SpawnPiece
		Spawns a new piece on the board
			The piece to be spawned is what is set to activepiece
			Piece spawn location is determined by x and y values for each piece in spawnlocx[][] and spawnlocy[][]
			First check those spawn locations and kill the player if something is already there
			Set the piece coordinates, piecex[] and piecey[], to the spawn locations of the activepiece
			This will be the piece that you move around the board and rotate etc.
			Sets rotnum and lastrot to zero. This will be important later, when dealing with rotation
			
	MovePiece
		Moves the piece x value by direction, which is set before the function is called
			First, check to see if the piece can be moved in the direction, checking to see if the piece will go over a placed piece, or off the board
			If the piece passes the check, move it in direction
	
	RotatePiece
	
	NOTICE: FOR MORE INFORMATION ON KICK TABLES AND I AND O ROTATION I HIGHLY RECOMMEND THAT YOU STARE AT THE CHARTS ON https://harddrop.com/wiki/SRS
		Rotates the piece in either direction, uses SRS as the kick table
			First, change rotnum, to keep track of which rotation state the piece is on
			If rotnum is -1, set it to 3, if it's four, set to 0
			Check to see if the piece is an i or o piece
				For i or o
					Determine the axis of the piece by looking at the direction the piece is rotating
					Set tempx and tempy so that a piece can be operated with without actual changes
					Rotate the piece around its axis in the appropriate direction
					Move the piece in a certain direction based off last rotation state and current rotation state because srs is stupid
					[A kick table is a table that lists x and y values to move the piece by if something is obstructing the piece (the side of the board or a placed block)]
					Determine which kick table to use as a base based off current and last rotation state
					Generate a kick table to finally use to kick the piece with
				For all other pieces
					Set tempx and tempy to piecex and piecey to operate on
					Determine the direction for the x values on the kick table based on current and previous rotation state
					Rotate the piece around its axis in the appropriate direction
					Generate
			Main loop for kicks
				Test the piece to see if something is obstructing it (off the board, something placed there already)
				If something is there, then move the piece as stated in the kick table that is generated
				Repeat
			If a rotation is successful (passed one of the five kick table checks, if not nothing happens) update numbers listing rotation state
					
	HoldPiece
		Switches the current piece for the one in the hold section
			Check to see if there is not a piece in the hold section
			If there is not, then hold the current piece, advance the queue, and spawn another piece
			If there is, then swap the hold piece with the current piece in the queue, then spawn the new piece
	
	HardDrop
		Places the current piece down
			Runs a check to see if theres a block or the ground r units underneath the current piece
			If there is something there, then change the board at the piece coordinates minus r to the number of the current piece, then run LineClear, then MoveQueue, then SpawnPiece
			If nothing is there, then increment r and check again
	
	SoftDrop
		Lowers the piece down
			Run a check to see if something is below the current piece
			If nothing is there, then lower the y value of the piece by one
			If there is something there, then do nothing
	
	main
		Initialize everything
			Set the random seed
			Make an initial queue
			Spawn a piece
		Main loop runs while player is still alive, dictated by variable death
			Accept input
			Certain inputs call certain functions
			Before some functions are called, a variable may be set, such as the direction a piece rotates, or moves
			runs print functions		
	